\chapter{Introduction}%

Performance is serious business for a scientific programming language. Success
in that niche hinges on the availability of a rich ecosystem of high-performance
mathematical and algorithm libraries. Julia is a relative newcomer in this space.
Its approach to scientific computing is predicated on the bet that
users can write efficient numerical code in Julia without needing to resort to C
or Fortran.
%
The design of the language is a balancing act between productivity features, such
as multiple dispatch and garbage collection, and performance features, such as
limited inheritance and restricted-by-default dynamic code loading.
Julia has been designed to ensure that a
relatively straightforward path exists from source code to machine code,
and its performance results are encouraging. They show, on some simple benchmarks,
speeds in between those of C and Java. In other words, a new dynamic language
written by a small team of language engineers can compete with mature, statically
typed languages and their highly tuned compilers.

Writing efficient Julia code is best viewed as a dialogue between the programmer
and the compiler.
From its earliest days, Julia exposed the compiler's intermediate representation
to users, encouraging them to (1) observe if and how the compiler is able to optimize
their code, and (2) adapt their coding style to warrant optimizations. This came with a
simple execution model: each time a function is called with a different tuple of
concrete argument types, a new \emph{specialization} is generated by Julia's
just-in-time compiler. That specialization leverages the run-time type information
about the arguments, to apply \emph{unboxing} and \emph{devirtualization} transformations
to the code. The former lets the compiler manipulate values without indirection
and stack allocate them; the latter sidesteps the powerful but costly
multiple-dispatch mechanism and enables inlining of callees.

One key to performance in Julia
stems from the compiler's success in determining the \emph{concrete} return
type of any function call it encounters. The intuition is that in such cases,
the compiler is able to propagate precise type information as it traverses the
code, which, in turn, is crucial for unboxing and devirtualization.
More precisely, Julia makes an important distinction between
concrete and abstract types: a concrete type such as \c{Int64}, is final
in the sense that the compiler knows the size and exact layout of
values of that type; for values of abstract types such as \c{Number}, the compiler has
no information. The property I alluded to is called \emph{type stability}.
Its informal definition states that a method is type stable if the concrete type of its
output is entirely determined by the concrete types of its arguments.\footnote{
\url{https://docs.julialang.org/en/v1/manual/faq/\#man-type-stability}} Folklore
suggests that one should strive to write type-stable methods outright, or, if
performance is an issue, refactor methods so that they become type stable.


My goal in this dissertation is three-fold.
%
First, I show that type stability is exhibited widely in practical Julia
packages.
%
Second, I formalize the relationship between type-stable code and the
ability of a just-in-time (JIT) compiler to perform type-based optimizations
during program execution.
%
Finally, I devise a procedure to statically approximate type stability, wich
allows Julia programmers to check stability without running their
code or supplying sample inputs.
% to this end, we find
% that a stronger property, which we call \emph{type groundedness}, describes
% optimizable code more precisely.
%is a better match to the goal of increasing performance.
%
% Finally, we analyze prevalence of type stability in open-source Julia code
% and identify patterns of type-stable code.
%evaluate how much type stability
%shows in the real world and what other code properties it possibly affects.
% We make the following contributions:

% \begin{itemize}
%   \item An overview of type stability and its role in Julia, as well as the
%     intuition behind stability and groundedness (\secref{sec:stability}).
%   \item An abstract machine called \jules, which models Julia's intermediate
%     representation, dynamic semantics, and just-in-time (JIT) compilation
%     (\secref{sec:jules}).
%   \item Formal definitions of groundedness and stability, and a proof that
%     type-grounded methods are fully devirtualized by the JIT compiler
%     (\secref{sec:stability-formal}). \ADD{Additionally, we prove that the JIT
%     compilation is correct with respect to the dynamic-dispatch semantics
%     (\secref{sec:jit-correct}). \PAPERVERSIONINLINE{Detailed proofs are available
%     in the extended version of the paper~\cite{oopsla21jules:arx}.}{}}
%   \item A corpus analysis of packages to measure stability and groundedness in
%     the wild, find patterns of type-stable code, and identify properties
%     that correlate with unstable code (\secref{sec:empirical}).
% \end{itemize}
% The thesis is accompanied by a software artifact~\cite{artifact} reproducing results
% of~\secref{sec:empirical}.


\section{Thesis Statement}
\label{chap-problem}

Optimizing dynamic languages is difficult and remains an active research field.
Several state-of-the-art JIT compilers perform the job well at the expense of being
opaque and unpredictable for the user.
Julia's unique design seemingly proposes a better approach based on the notion
of type stability. My thesis is, therefore:

\begin{itquote}
Type stability
is a widely used program property that can be leveraged by a compiler to generate
correct and efficient code
and can be approximated by automated techniques.
\end{itquote}

To validate this thesis, I make the following contributions:
\begin{enumerate}

  \item
  Assess how widely type-stable code is deployed inside Julia's ecosystem, and
  whether any code patterns are associated with type-stable code.

  \item
  Establish a formal correspondence between type stability and code optimizations and
  show that optimized code is semantically equivalent to the initial version.

  \item
  Design an approach for approximating type stability through a static analysis and
  demonstrate the practicality of the approach by building a tool for source code analysis.
\end{enumerate}

% maybe limitations?

This work builds on a number of papers that I have (co-)written, in particular:
\begin{itemize}
  \item \emph{Julia Subtyping: A Rational Reconstruction} (OOPSLA 2018)\\
  By Francesco Zappa Nardelli, Julia Belyakova, \textbf{Artem Pelenitsyn},
  Benjamin Chung, Jeff Bezanson, and Jan Vitek~\cite{oopsla18b}

  \item \emph{Type Stability in Julia: Avoiding Performance Pathologies in JIT
  Compilation} (OOPSLA 2021)\\
  By \textbf{Artem Pelenitsyn}, Julia Belyakova, Benjamin Chung, Ross Tate, and Jan
  Vitek~\cite{Pelenitsyn21}

  \item \emph{Approximating Type Stability in The Julia JIT (work-in-progress)} (VMIL 2023)\\
  By \textbf{Artem Pelenitsyn} [To appear]
\end{itemize}
